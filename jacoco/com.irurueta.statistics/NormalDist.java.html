<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NormalDist.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.irurueta:irurueta-statistics</a> &gt; <a href="index.source.html" class="el_package">com.irurueta.statistics</a> &gt; <span class="el_source">NormalDist.java</span></div><h1>NormalDist.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2015 Alberto Irurueta Carro (alberto@irurueta.com)
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.irurueta.statistics;

/**
 * Contains methods to work with normal (i.e. Gaussian) distributions.
 * Methods of this class use methods of the Erf class.
 * This class is based in code of Numerical Recipes 3rd ed. section 6.14.1.
 */
public class NormalDist {
    /**
     * Square root of 2.
     */
<span class="fc" id="L27">    private static final double SQRT2 = Math.sqrt(2.0);</span>

    /**
     * Square root of 2 divided by 2.
     */
<span class="fc" id="L32">    private static final double HALF_SQRT2 = SQRT2 / 2.0;</span>

    /**
     * Term to normalize Gaussian so that its integral from -infinity to infinity is one.
     */
<span class="fc" id="L37">    private static final double GAUSSIAN_NORM = 1.0 / Math.sqrt(2.0 * Math.PI);</span>

    /**
     * Mean value of Gaussian distribution.
     */
    private double mu;

    /**
     * Standard deviation of Gaussian distribution.
     */
    private double sig;

    /**
     * Constructor. Initializes a Gaussian distribution with zero mean and
     * unitary standard deviation (i.e. N(0,1)).
     */
<span class="fc" id="L53">    public NormalDist() {</span>
<span class="fc" id="L54">        mu = 0.0;</span>
<span class="fc" id="L55">        sig = 1.0;</span>
<span class="fc" id="L56">    }</span>

    /**
     * Constructor with mean and standard deviation.
     *
     * @param mu  mean value of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @throws IllegalArgumentException if provided standard deviation is zero
     *                                  or negative.
     */
<span class="fc" id="L66">    public NormalDist(final double mu, final double sig) {</span>
<span class="fc" id="L67">        setStandardDeviation(sig);</span>
<span class="fc" id="L68">        setMean(mu);</span>
<span class="fc" id="L69">    }</span>

    /**
     * Gets mean value of Gaussian distribution.
     *
     * @return mean value of Gaussian distribution.
     */
    public double getMean() {
<span class="fc" id="L77">        return mu;</span>
    }

    /**
     * Sets mean value of Gaussian distribution.
     *
     * @param mu mean value of Gaussian distribution.
     */
    public final void setMean(final double mu) {
<span class="fc" id="L86">        this.mu = mu;</span>
<span class="fc" id="L87">    }</span>

    /**
     * Gets standard deviation of Gaussian distribution.
     *
     * @return standard deviation of Gaussian distribution.
     */
    public double getStandardDeviation() {
<span class="fc" id="L95">        return sig;</span>
    }

    /**
     * Sets standard deviation of Gaussian distribution.
     *
     * @param sig standard deviation to be set.
     * @throws IllegalArgumentException if provided standard deviation is zero
     *                                  or negative.
     */
    public final void setStandardDeviation(final double sig) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">        if (sig &lt;= 0.0) {</span>
<span class="fc" id="L107">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L109">        this.sig = sig;</span>
<span class="fc" id="L110">    }</span>

    /**
     * Gets variance of Gaussian distribution.
     *
     * @return variance of Gaussian distribution.
     */
    public double getVariance() {
<span class="fc" id="L118">        return sig * sig;</span>
    }

    /**
     * Sets variance of Gaussian distribution.
     *
     * @param variance variance of Gaussian distribution.
     * @throws IllegalArgumentException if provided variance is zero or
     *                                  negative.
     */
    public void setVariance(final double variance) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (variance &lt;= 0.0) {</span>
<span class="fc" id="L130">            throw new IllegalArgumentException(</span>
                    &quot;variance must be greater than zero&quot;);
        }
<span class="fc" id="L133">        sig = Math.sqrt(variance);</span>
<span class="fc" id="L134">    }</span>

    /**
     * Evaluates the probability density function (p.d.f.) of a Gaussian
     * distribution having mean mu and standard deviation sig at provided point
     * x.
     *
     * @param x   point where p.d.f. is evaluated.
     * @param mu  mean of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @return evaluation of p.d.f.
     * @throws IllegalArgumentException if provided standard deviation is zero
     *                                  or negative.
     */
    public static double p(final double x, final double mu, final double sig) {
<span class="fc bfc" id="L149" title="All 2 branches covered.">        if (sig &lt;= 0.0) {</span>
<span class="fc" id="L150">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L153">        return internalP(x, mu, sig);</span>
    }

    /**
     * Evaluates the probability density function (p.d.f.) of a Gaussian
     * distribution having the mean and standard deviation of this instance at
     * provided point x.
     *
     * @param x point where p.d.f. is evaluated.
     * @return evaluation of p.d.f.
     */
    public double p(final double x) {
<span class="fc" id="L165">        return internalP(x, mu, sig);</span>
    }

    /**
     * Evaluates the cumulative distribution function (c.d.f.) of a Gaussian
     * distribution having mean mu and standard deviation sig at provided point
     * x.
     * The c.d.f is equivalent to the probability of the Gaussian distribution
     * of having a value less than x, and it is computed as the integral from
     * -infinity to x of the Gaussian p.d.f.
     *
     * @param x   point where c.d.f. is evaluated.
     * @param mu  mean of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @return evaluation of c.d.f.
     * @throws IllegalArgumentException if provided standard deviation is zero
     *                                  or negative.
     */
    public static double cdf(final double x, final double mu, final double sig) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (sig &lt;= 0.0) {</span>
<span class="fc" id="L185">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L188">        return internalCdf(x, mu, sig);</span>
    }

    /**
     * Evaluates the cumulative distribution function (c.d.f.) of a Gaussian
     * distribution having the mean and standard deviation of this instance at
     * provided point x.
     * The c.d.f is equivalent to the probability of the Gaussian distribution
     * of having a value less than x, and it is computed as the integral from
     * -infinity to x of the Gaussian p.d.f.
     * Because the c.d.f is a probability, it always returns values between 0.0
     * and 1.0.
     *
     * @param x point where c.d.f. is evaluated.
     * @return evaluation of c.d.f.
     */
    public double cdf(final double x) {
<span class="fc" id="L205">        return internalCdf(x, mu, sig);</span>
    }

    /**
     * Evaluates the inverse cumulative distribution function of a Gaussian
     * distribution having mean mu and standard deviation sig at provided point
     * p.
     * Because the c.d.f is a monotonically increasing function with values
     * between 0.0 and 1.0, its inverse is uniquely defined between such range
     * of values.
     *
     * @param p   value to evaluate the inverse c.d.f. at. This value is
     *            equivalent to a probability and must be between 0.0 and 1.0.
     * @param mu  mean of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @return the value x for which the c.d.f. has value p.
     * @throws IllegalArgumentException if provided standard deviation is zero
     *                                  or negative, or if provided probability value is not between 0.0 and 1.0.
     */
    public static double invcdf(final double p, final double mu, final double sig) {
<span class="fc bfc" id="L225" title="All 2 branches covered.">        if (sig &lt;= 0.0) {</span>
<span class="fc" id="L226">            throw new IllegalArgumentException(&quot;standard deviation must be greater than zero&quot;);</span>
        }

<span class="fc" id="L229">        return internalInvcdf(p, mu, sig);</span>
    }

    /**
     * Evaluates the inverse cumulative distribution function of a Gaussian
     * distribution having the mean and standard deviation of this instance at
     * provided point p.
     * Because the c.d.f is a monotonically increasing function with values
     * between 0.0 and 1.0, its inverse is uniquely defined between such range
     * of values.
     *
     * @param p value to evaluate the inverse c.d.f. at. This value is
     *          equivalent to a probability and must be between 0.0 and 1.0.
     * @return the value x for which the c.d.f. has value p.
     * @throws IllegalArgumentException if provided probability value is not
     *                                  between 0.0 and 1.0.
     */
    public double invcdf(final double p) {
<span class="fc" id="L247">        return internalInvcdf(p, mu, sig);</span>
    }

    /**
     * Computes the Mahalanobis distance of provided point x for provided
     * mean and standard deviation values.
     *
     * @param x   point where Mahalanobis distance is evaluated.
     * @param mu  mean of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @return Mahalanobis distance of provided point respect to mean.
     * @throws IllegalArgumentException if provided standard deviation is zero
     *                                  or negative.
     */
    public static double mahalanobisDistance(final double x, final double mu, final double sig) {
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (sig &lt;= 0.0) {</span>
<span class="fc" id="L263">            throw new IllegalArgumentException(&quot;standard deviation must be greater than zero&quot;);</span>
        }

<span class="fc" id="L266">        return internalMahalanobisDistance(x, mu, sig);</span>
    }

    /**
     * Computes the Mahalanobis distance of provided point x for current mean
     * and standard deviation values.
     *
     * @param x point where Mahalanobis distance is evaluated.
     * @return Mahalanobis distance of provided point respect to current mean.
     */
    public double mahalanobisDistance(final double x) {
<span class="fc" id="L277">        return internalMahalanobisDistance(x, mu, sig);</span>
    }

    /**
     * Evaluates the probability density function (p.d.f.) of a Gaussian
     * distribution having mean mu and standard deviation sig at provided point
     * x.
     * This method is used internally.
     *
     * @param x   point where p.d.f. is evaluated.
     * @param mu  mean of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @return evaluation of p.d.f.
     * @throws IllegalArgumentException if provided standard deviation is zero
     *                                  or negative.
     */
    private static double internalP(final double x, final double mu, final double sig) {
<span class="fc" id="L294">        return (GAUSSIAN_NORM / sig) * Math.exp(-0.5 * Math.pow((x - mu) / sig, 2.0));</span>
    }

    /**
     * Evaluates the cumulative distribution function (c.d.f.) of a Gaussian
     * distribution having mean mu and standard deviation sig at provided point
     * x.
     * The c.d.f is equivalent to the probability of the Gaussian distribution
     * of having a value less than x, and it is computed as the integral from
     * -infinity to x of the Gaussian p.d.f.
     * This method is used internally.
     *
     * @param x   point where c.d.f. is evaluated.
     * @param mu  mean of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @return evaluation of c.d.f.
     * @throws IllegalArgumentException if provided standard deviation is zero
     *                                  or negative.
     */
    private static double internalCdf(final double x, final double mu, final double sig) {
<span class="fc" id="L314">        return 0.5 * Erf.erfc(-HALF_SQRT2 * (x - mu) / sig);</span>
    }

    /**
     * Evaluates the inverse cumulative distribution function of a Gaussian
     * distribution having mean mu and standard deviation sig at provided point
     * p.
     * Because the c.d.f is a monotonically increasing function with values
     * between 0.0 and 1.0, its inverse is uniquely defined between such range
     * of values.
     * This method is used internally.
     *
     * @param p   value to evaluate the inverse c.d.f. at. This value is
     *            equivalent to a probability and must be between 0.0 and 1.0.
     * @param mu  mean of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @return the value x for which the c.d.f. has value p.
     * @throws IllegalArgumentException if provided probability value is not
     *                                  between 0.0 and 1.0.
     */
    private static double internalInvcdf(final double p, final double mu, final double sig)
            throws IllegalArgumentException {
<span class="fc bfc" id="L336" title="All 4 branches covered.">        if (p &lt;= 0.0 || p &gt;= 1.0) {</span>
<span class="fc" id="L337">            throw new IllegalArgumentException(&quot;probability value must be between 0.0 and 1.0&quot;);</span>
        }
<span class="fc" id="L339">        return -SQRT2 * sig * Erf.inverfc(2.0 * p) + mu;</span>
    }

    /**
     * Computes the Mahalanobis distance of provided point x for provided
     * mean and standard deviation values.
     *
     * @param x   point where Mahalanobis distance is evaluated.
     * @param mu  mean of Gaussian distribution.
     * @param sig standard deviation of Gaussian distribution.
     * @return Mahalanobis distance of provided point respect to mean.
     */
    private static double internalMahalanobisDistance(final double x, final double mu, final double sig) {
<span class="fc" id="L352">        return Math.abs(x - mu) / sig;</span>
    }

    /**
     * Evaluates the derivative and a 1D function at a certain mean point and
     * computes the non-linear propagation of Gaussian uncertainty through such
     * function at such point.
     *
     * @param evaluator         interface to evaluate derivative of a function at a
     *                          certain point.
     * @param mean              mean of original Gaussian distribution to be propagated.
     * @param standardDeviation standard deviation of original Gaussian
     *                          distribution to be propagated.
     * @param result            instance where propagated Gaussian distribution will be
     *                          stored.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void propagate(
            final DerivativeEvaluator evaluator, final double mean, final double standardDeviation,
            final NormalDist result) {
<span class="fc" id="L372">        final var evaluation = evaluator.evaluate(mean);</span>
<span class="fc" id="L373">        final var derivative = evaluator.evaluateDerivative(mean);</span>
<span class="fc" id="L374">        result.setMean(evaluation);</span>
<span class="fc" id="L375">        result.setStandardDeviation(Math.abs(derivative * standardDeviation));</span>
<span class="fc" id="L376">    }</span>

    /**
     * Evaluates the derivative and a 1D function at a certain mean point and
     * computes the non-linear propagation of Gaussian uncertainty through such
     * function at such point.
     *
     * @param evaluator         interface to evaluate derivative of a function at a
     *                          certain point.
     * @param mean              mean of original Gaussian distribution to be propagated.
     * @param standardDeviation standard deviation of original Gaussian
     *                          distribution to be propagated.
     * @return a new propagated Gaussian distribution.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static NormalDist propagate(
            final DerivativeEvaluator evaluator, final double mean, final double standardDeviation) {
<span class="fc" id="L393">        final var result = new NormalDist();</span>
<span class="fc" id="L394">        propagate(evaluator, mean, standardDeviation, result);</span>
<span class="fc" id="L395">        return result;</span>
    }

    /**
     * Evaluates the derivative and a 1D function at a certain mean point and
     * computes the non-linear propagation of Gaussian uncertainty through such
     * function at such point.
     *
     * @param evaluator interface to evaluate derivative of a function at a
     *                  certain point.
     * @param dist      1D Gaussian distribution to be propagated.
     * @param result    instance where propagated Gaussian distribution will be
     *                  stored.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static void propagate(final DerivativeEvaluator evaluator, final NormalDist dist, final NormalDist result) {
<span class="fc" id="L411">        propagate(evaluator, dist.getMean(), dist.getStandardDeviation(), result);</span>
<span class="fc" id="L412">    }</span>

    /**
     * Evaluates the derivative and a 1D function at a certain mean point and
     * computes the non-linear propagation of Gaussian uncertainty through such
     * function at such point.
     *
     * @param evaluator interface to evaluate derivative of a function at a
     *                  certain point.
     * @param dist      1D Gaussian distribution to be propagated.
     * @return a new propagated Gaussian distribution.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public static NormalDist propagate(final DerivativeEvaluator evaluator, final NormalDist dist) {
<span class="fc" id="L426">        final var result = new NormalDist();</span>
<span class="fc" id="L427">        propagate(evaluator, dist, result);</span>
<span class="fc" id="L428">        return result;</span>
    }

    /**
     * Evaluates the derivative and a 1D function at the mean point of this
     * normal distribution and computes the non-linear propagation of Gaussian
     * uncertainty through such function at such point.
     *
     * @param evaluator interface to evaluate derivative of a function at the
     *                  mean point of this normal distribution.
     * @param result    instance where propagated Gaussian distribution will be
     *                  stored.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public void propagateThisDistribution(final DerivativeEvaluator evaluator, final NormalDist result) {
<span class="fc" id="L443">        propagate(evaluator, this, result);</span>
<span class="fc" id="L444">    }</span>

    /**
     * Evaluates the derivative and a 1D function at the mean point of this
     * normal distribution and computes the non-linear propagation of Gaussian
     * uncertainty through such function at such point.
     *
     * @param evaluator interface to evaluate derivative of a function at the
     *                  mean point of this normal distribution.
     * @return a new propagated Gaussian distribution.
     * @see &lt;a href=&quot;https://github.com/joansola/slamtb&quot;&gt;propagateUncertainty.m at https://github.com/joansola/slamtb&lt;/a&gt;
     */
    public NormalDist propagateThisDistribution(final DerivativeEvaluator evaluator) {
<span class="fc" id="L457">        final var result = new NormalDist();</span>
<span class="fc" id="L458">        propagateThisDistribution(evaluator, result);</span>
<span class="fc" id="L459">        return result;</span>
    }

    /**
     * Interface to evaluate a one dimensional function at point x and to obtain
     * its derivative at such point.
     */
    public interface DerivativeEvaluator {

        /**
         * Evaluates function at point x.
         *
         * @param x point x where derivative is evaluated.
         * @return evaluation of function at point x.
         */
        double evaluate(final double x);

        /**
         * Evaluates derivative of a function at point x.
         *
         * @param x point x where derivative is evaluated.
         * @return derivative of one dimensional function at point x.
         */
        double evaluateDerivative(final double x);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>